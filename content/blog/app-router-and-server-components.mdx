---
title: "Getting Started with Next.js 14: App Router and Server Components"
date: "2024-02-15"
lastUpdated: "2024-02-20"
excerpt: "Learn how to build modern web applications with Next.js 14, leveraging the power of App Router and React Server Components"
author:
  name: "Sarah Johnson"
  avatar: "/api/placeholder/100/100"
  title: "Senior Frontend Developer"
  bio: "Sarah is a senior frontend developer with 8 years of experience specializing in React and modern JavaScript frameworks."
  twitter: "sarahjdev"
  github: "sarahjohnson"
coverImage: "/api/placeholder/1200/630"
tags: ["Next.js", "React", "Server Components", "Web Development"]
category: "Web Development"
featured: true
seoTitle: "Next.js 14 Tutorial: App Router and Server Components Guide"
seoDescription: "Learn how to build faster, more efficient web applications with Next.js 14's App Router and React Server Components"
seoKeywords: ["Next.js 14", "Server Components", "App Router", "React", "Web Development", "JavaScript"]
---

# Getting Started with Next.js 14

Next.js 14 introduces powerful new features that transform how we build web applications. In this guide, we'll explore the new App Router architecture and how to leverage React Server Components for better performance and developer experience.

## What's New in Next.js 14

Next.js 14 builds upon the foundation laid by version 13, refining the App Router and Server Components while introducing several performance improvements and developer experience enhancements.

<Callout type="info">
  Next.js 14 was released in October 2023 and focuses on stability and performance improvements over Next.js 13.
</Callout>

Here are some of the key updates:

- **Improved Stability**: The App Router has matured significantly with numerous bug fixes and optimizations
- **Turbopack Updates**: Faster development server with improved HMR support
- **Server Actions**: Officially stable for form handling and data mutations
- **Partial Prerendering (Preview)**: Combine static and dynamic content seamlessly

## Understanding App Router

The App Router is a file-system based router built on top of React's new components and data fetching features. It supports layouts, nested routing, loading states, error handling, and more.

```jsx
// app/page.tsx - Server Component by default
export default function HomePage() {
  return (
    <main>
      <h1>Welcome to my Next.js 14 site</h1>
      <p>This page is a server component by default</p>
    </main>
  );
}
```

### Key Features of App Router

The App Router introduces several important concepts:

1. **Server Components**: Render on the server for improved performance
2. **Layouts**: Shared UI across multiple pages
3. **Server Actions**: Mutations without API endpoints
4. **Streaming and Suspense**: Progressive rendering for better UX

## Working with Server Components

Server Components represent a paradigm shift in how we build React applications. They execute on the server, reducing the client-side JavaScript bundle and enabling direct access to backend resources.

### Benefits of Server Components

- **Reduced Client-Side JavaScript**: Components that don't need interactivity stay on the server
- **Direct Backend Access**: Query databases and access secrets securely
- **Automatic Code Splitting**: Improved performance without manual configuration
- **Improved SEO**: Better initial load performance and content indexing

## Creating a Simple Server Component

Let's create a simple server component that fetches and displays data:

```jsx
// app/posts/page.tsx
async function getPosts() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  if (!res.ok) throw new Error('Failed to fetch posts');
  return res.json();
}

export default async function PostsPage() {
  // This async component will be rendered on the server
  const posts = await getPosts();
  
  return (
    <div>
      <h1>Blog Posts</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>
            <h2>{post.title}</h2>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

<Callout type="warning">
  Server Components cannot use hooks like useState or useEffect, or browser-only APIs. If you need these features, use a Client Component.
</Callout>

## Client Components for Interactivity

When you need interactivity, use Client Components with the "use client" directive:

```jsx
'use client'

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

## Server and Client Component Patterns

A common pattern is to use Server Components for data fetching and Client Components for interactivity:

```jsx
// app/dashboard/page.tsx (Server Component)
import UserProfile from './user-profile';

async function getUserData(id) {
  const res = await fetch(`https://api.example.com/users/${id}`);
  return res.json();
}

export default async function DashboardPage() {
  const userData = await getUserData('123');
  
  return (
    <div>
      <h1>Dashboard</h1>
      <UserProfile user={userData} />
    </div>
  );
}
```

```jsx
// app/dashboard/user-profile.tsx (Client Component)
'use client'

import { useState } from 'react';

export default function UserProfile({ user }) {
  const [isEditing, setIsEditing] = useState(false);
  
  return (
    <div>
      <h2>{user.name}</h2>
      <button onClick={() => setIsEditing(!isEditing)}>
        {isEditing ? 'Cancel' : 'Edit Profile'}
      </button>
      
      {isEditing && (
        <form>
          {/* Form fields */}
        </form>
      )}
    </div>
  );
}
```

## Using Layouts

Layouts in the App Router allow you to share UI between multiple pages:

```jsx
// app/layout.tsx
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <header>
          <nav>{/* Navigation */}</nav>
        </header>
        <main>{children}</main>
        <footer>{/* Footer */}</footer>
      </body>
    </html>
  );
}
```

## Data Fetching with Server Components

Server Components make data fetching straightforward:

```jsx
// app/products/[id]/page.tsx
async function getProduct(id) {
  const res = await fetch(`https://api.example.com/products/${id}`, {
    cache: 'no-store' // Don't cache this request
  });
  
  if (!res.ok) {
    // This will be caught by the error boundary
    throw new Error('Failed to fetch product');
  }
  
  return res.json();
}

export default async function ProductPage({ params }) {
  const product = await getProduct(params.id);
  
  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <p>${product.price}</p>
    </div>
  );
}
```

## Working with Forms and Server Actions

Next.js 14 makes form handling simpler with Server Actions:

```jsx
// app/contact/page.tsx
export default function ContactPage() {
  async function submitForm(formData: FormData) {
    'use server'
    
    const name = formData.get('name');
    const email = formData.get('email');
    const message = formData.get('message');
    
    // Save to database, send email, etc.
    console.log({ name, email, message });
    
    // Revalidate the page
    revalidatePath('/contact');
  }
  
  return (
    <form action={submitForm}>
      <div>
        <label htmlFor="name">Name</label>
        <input type="text" id="name" name="name" required />
      </div>
      <div>
        <label htmlFor="email">Email</label>
        <input type="email" id="email" name="email" required />
      </div>
      <div>
        <label htmlFor="message">Message</label>
        <textarea id="message" name="message" required></textarea>
      </div>
      <button type="submit">Send Message</button>
    </form>
  );
}
```

## Conclusion

Next.js 14 with App Router and React Server Components provides a powerful framework for building modern web applications. By understanding the distinction between Server and Client Components, you can create faster, more efficient applications that provide excellent user experiences.



The best way to learn is by doing, so I encourage you to create a new Next.js 14 project and start experimenting with these concepts. Happy coding!